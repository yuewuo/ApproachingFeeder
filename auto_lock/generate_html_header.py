#!/usr/bin/env python3
"""
Generate html_content.hpp from auto_lock.html

This script reads the HTML file and generates a C++ header with the content
embedded as a PROGMEM string literal for ESP32.

Usage:
    python generate_html_header.py

Or via Makefile:
    make html
"""

import os
import re

INPUT_FILE = "auto_lock.html"
OUTPUT_FILE = "html_content.hpp"


def minify_html(html: str) -> str:
    """Basic HTML minification - remove unnecessary whitespace."""
    # Remove HTML comments
    html = re.sub(r"<!--.*?-->", "", html, flags=re.DOTALL)
    # Remove whitespace between tags
    html = re.sub(r">\s+<", "><", html)
    # Remove leading/trailing whitespace from lines
    html = "\n".join(line.strip() for line in html.split("\n") if line.strip())
    # Collapse multiple spaces
    html = re.sub(r" {2,}", " ", html)
    return html


def generate_header(html_content: str, minify: bool = True) -> str:
    """Generate C++ header file content."""

    if minify:
        html_content = minify_html(html_content)

    header = (
        """#ifndef HTML_CONTENT_HPP
#define HTML_CONTENT_HPP

// Auto-generated from auto_lock.html
// Do not edit this file directly - edit auto_lock.html and run:
//   python generate_html_header.py
// Or:
//   make html

const char HTML_PAGE[] PROGMEM = R"rawliteral("""
        + html_content
        + """)rawliteral";

#endif // HTML_CONTENT_HPP
"""
    )
    return header


def main():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    input_path = os.path.join(script_dir, INPUT_FILE)
    output_path = os.path.join(script_dir, OUTPUT_FILE)

    if not os.path.exists(input_path):
        print(f"Error: {INPUT_FILE} not found")
        return 1

    with open(input_path, "r", encoding="utf-8") as f:
        html_content = f.read()

    header_content = generate_header(html_content, minify=True)

    with open(output_path, "w", encoding="utf-8") as f:
        f.write(header_content)

    html_size = len(html_content)
    header_size = len(header_content)
    minified_size = len(minify_html(html_content))

    print(f"Generated {OUTPUT_FILE}")
    print(f"  Original HTML: {html_size:,} bytes")
    print(f"  Minified HTML: {minified_size:,} bytes ({100*minified_size//html_size}%)")
    print(f"  Header file:   {header_size:,} bytes")

    return 0


if __name__ == "__main__":
    exit(main())
